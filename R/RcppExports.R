# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Use Dollo's parsimony distance to evaluate similarity patterns.
#'
#' Algorithm:
#' 1. Find the latest common ancestors (LCA) for all gain tips.
#' 2. Select the nodes from each tip to the LCA.
#'
#' InferGainNodes(): Infer the present nodes and tips.
#'
#' DolloDist(): Infer the Dollo's parsimony distance.
#'
#' InferEdge(): Infer the present and absent of each edges.
#'
#' @title Dollo's parsimony distance
#' @param gainList A list of ancestors of each gain tips. In each elements, the first one is the root.
#' @return
#'
#' InferGainNodes(): A vector (with tips) of 1 and 0.
#'
#' DolloDist(): An integer.
#'
#' InferEdge(): A numeric edge present and absent matrix.
#'
#' @examples
#' ## example tree
#' library('ape')
#' testTreeText <- '((((t1, t2),(t3, t4)),t5), (t6, (t7, t8)));'
#' testTree <- read.tree(text = testTreeText)
#' plot(testTree)
#'
#' ## node path
#' pathList <- nodepath(testTree)
#' InferGainNodes(pathList[1])
#' InferGainNodes(pathList[1:3])
#'
#' InferEdge(testTree$edge, pathList, c(0, 0, 0, 0, 1, 1, 1, 1))
#'
#' DolloDist(testTree$edge, pathList, c(0, 0, 0, 0, 1, 1, 1, 1), c(0, 0, 0, 0, 0, 1, 1, 1))
#' DolloDist(testTree$edge, pathList, c(1, 1, 1, 1, 1, 0, 0, 1), c(0, 0, 0, 0, 1, 0, 0, 1))
#' @author Yulong Niu \email{niuylscu@@gmail.com}
#' @rdname dollo
#' @export
InferGainNodes <- function(gainList) {
    .Call('PhyloProfile_InferGainNodes', PACKAGE = 'PhyloProfile', gainList)
}

#' @param edgeMat A edge mat could be generated from the "ape" package.The first row should be (root --> nodes).
#' @param tipPath  A list of ancestors of each gain tips. In each elements, the first one is the root.
#' @param pr A numeric vector indicates the "presence-absence" pattern."pr" should be in the same order with the tips of tree
#' @rdname dollo
#' @export
InferEdge <- function(edgeMat, tipPath, pr) {
    .Call('PhyloProfile_InferEdge', PACKAGE = 'PhyloProfile', edgeMat, tipPath, pr)
}

#' @param pr1 1st "presence-absence" pattern.
#' @param pr2 2nd "presence-absence" pattern.
#' @inheritParams InferEdge
#' @return A number indicating the Dollo's parsimony distance.
#' @rdname dollo
#' @references \url{https://www.ncbi.nlm.nih.gov/pubmed/?term=17535793}
#' @export
DolloDist <- function(edgeMat, tipPath, pr1, pr2) {
    .Call('PhyloProfile_DolloDist', PACKAGE = 'PhyloProfile', edgeMat, tipPath, pr1, pr2)
}

#' @param x A list only contains unsigned interger vectors.
#' @return A merged numeric vector.
#' @rdname dollo
#' @keywords internal
MergeList <- function(x) {
    .Call('PhyloProfile_MergeList', PACKAGE = 'PhyloProfile', x)
}

#' @inheritParams SimCor
#' @rdname simdist
#' @export
SimMIBin <- function(pairProfile) {
    .Call('PhyloProfile_SimMIBin', PACKAGE = 'PhyloProfile', pairProfile)
}

#' Utilities for MI
#'
#' \code{eachMI()}: Info for a cell.
#' \code{Info()}: Entropy.
#' \code{HistTwo()}: Joint counts of two vectors.
#' \code{FindInter()}: Interval indices of a vector.
#' \code{FindInterSingle()}: Interval index of a value.
#' \code{gInter()}: Generate an interval vector, inspired from the \code{cut()} function of the \code{base} package.
#' \code{CountRepeat()}: Repeat counts of a vector.
#'
#' @param p1, p2, p3: Counts of variables in cells.
#' @param n Total variables.
#' @author Yulong Niu \email{niuylscu@@gmail.com}
#' @rdname utilities-MI
#' @keywords internal
eachMI <- function(p1, p2, p3, n) {
    .Call('PhyloProfile_eachMI', PACKAGE = 'PhyloProfile', p1, p2, p3, n)
}

#' @inheritParams SimCor
#' @param bin Integer.
#' @rdname simdist
#' @export
SimMIConti <- function(pairProfile, bin) {
    .Call('PhyloProfile_SimMIConti', PACKAGE = 'PhyloProfile', pairProfile, bin)
}

#' @param v Histogram of counts.
#' @inheritParams eachMI
#' @rdname utilities-MI
#' @keywords internal
Info <- function(v, n) {
    .Call('PhyloProfile_Info', PACKAGE = 'PhyloProfile', v, n)
}

#' @inheritParams SimMIConti
#' @param x, y Numeric vector.
#' @rdname utilities-MI
#' @keywords internal
HistTwo <- function(x, y, bin) {
    .Call('PhyloProfile_HistTwo', PACKAGE = 'PhyloProfile', x, y, bin)
}

#' @inheritParams HistTwo
#' @param internal Interval numeric vector.
#' @rdname utilities-MI
#' @keywords internal
FindInter <- function(x, interval) {
    .Call('PhyloProfile_FindInter', PACKAGE = 'PhyloProfile', x, interval)
}

#' @inheritParams FindInter
#' @param value Number.
#' @rdname utilities-MI
#' @keywords internal
FindInterSingle <- function(value, interval) {
    .Call('PhyloProfile_FindInterSingle', PACKAGE = 'PhyloProfile', value, interval)
}

#' @inheritParams HistTwo
#' @rdname utilities-MI
#' @keywords internal
gInter <- function(x, bin) {
    .Call('PhyloProfile_gInter', PACKAGE = 'PhyloProfile', x, bin)
}

#' @inheritParams HistTwo
#' @rdname utilities-MI
#' @keywords internal
CountRepeat <- function(x) {
    .Call('PhyloProfile_CountRepeat', PACKAGE = 'PhyloProfile', x)
}

#' NPP normalization
#'
#' Algorithm:
#'
#' Step1: rawBitM < hitCutoff to hitReset;
#'
#' Step2: filter genes without enough homologys
#'
#' Step3: in each row (species), log2(x/max(x));
#'
#' Step4: z-score for each column.
#' 
#' @title z-score normalization of phylogenetic profile
#' @return
#'
#' NPPNorm(): NPP normalized bit score matrix.
#'
#' @author Yulong Niu \email{niuylscu@@gmail.com}
#' @inheritParams SVDNorm
#' @references \href{http://www.nature.com/nature/journal/v493/n7434/extref/nature11779-s1.pdf}{NPP description}
#' @keywords internal
NPPNorm <- function(rawBitM, bitCutoff, bitReset, minConserve) {
    .Call('PhyloProfile_NPPNorm', PACKAGE = 'PhyloProfile', rawBitM, bitCutoff, bitReset, minConserve)
}

#' SVD normalization
#'
#' Algorithm:
#'
#' Step1: rawBitM < bitCutoff to bitReset;
#'
#' Step2: In each row (species), x/max(x);
#'
#' Step3: L^2 SVD normalization.
#'
#' The core SVD normalization is retrieved from the SVD-Phy package with performance modification.
#' @title Singular value decomposition normalization of bit score matrix
#' @param rawBitM Raw bit score matrix.
#' @param bitCutoff Minimum value of the bit score.
#' @return
#'
#' SVDNorm(): SVD normalized bit score matrix.
#'
#' SVDPhy(): A L^2 normalized unitary matrix.
#'
#' @author Yulong Niu \email{niuylscu@@gmail.com}
#' @inheritParams SVDPhy
#' @references \href{https://bitbucket.org/andrea/svd-phy}{SVD-Phy package}
#' @references \href{http://bioinformatics.oxfordjournals.org/content/suppl/2015/11/25/btv696.DC1/SVD-Phy-supplementary-material.docx}{SVD description}
#' @rdname normSVD
#' @keywords internal
SVDNorm <- function(rawBitM, bitCutoff, bitReset, minConserve, trimming) {
    .Call('PhyloProfile_SVDNorm', PACKAGE = 'PhyloProfile', rawBitM, bitCutoff, bitReset, minConserve, trimming)
}

#' @param bitM Bit score matrix, for example the BLASTP or STRING bit scores. It is a named numeric matrix, columns are species and rows are genes.
#' @param bitReset Reset the bit score for ones lower than the `bitCutoff`.
#' @param trimming A percentages top unitary matrix.
#' @param minConserve Minimum number of homologous. The proteins with homologous less than this value are discarded.
#' @rdname normSVD
#' @keywords internal
SVDPhy <- function(bitM, bitReset, minConserve, trimming) {
    .Call('PhyloProfile_SVDPhy', PACKAGE = 'PhyloProfile', bitM, bitReset, minConserve, trimming)
}

#' Similarity or distance of paired phylogenetic profile
#'
#' SimCor(): Person's correlation coefficient.
#' SimJaccard(): Jaccard similarity.
#' SimMIBin(): Mutual information for binning data.
#' SimMIConti(): Mutual information for continuous data.
#' DistHamming(): Hamming distance.
#' DistEuclidean(): Euclidean distance.
#'
#' @title similarity and distance
#' @param pairProfile A paired phylogenetic profile, columns are genes and rows are species.
#' @return A numeric value.
#' @examples
#' ## alpha and beta subunits from the F-type ATP synthase.
#' data(fatp)
#' ab <- t(fatp$atpPhylo[c('ATP5A1', 'ATP5B'), ])
#'
#' ## Person's correlation coefficient
#' corAB <- SimCor(ab)
#' ## Jaccard similarity
#' jacAB <- SimJaccard(ab)
#' ## Mutual information
#' MIAB <- SimMIBin(ab)
#' MIABConti <- SimMIConti(ab, bin = 10)
#' ## Hamming distance
#' hamAB <- DistHamming(ab)
#' ## Eulidean distance
#' euAB <- DistEuclidean(ab)
#' @author Yulong Niu \email{niuylscu@@gmail.com}
#' @rdname simdist
#' @seealso SimDistBatch
#' @export
SimCor <- function(pairProfile) {
    .Call('PhyloProfile_SimCor', PACKAGE = 'PhyloProfile', pairProfile)
}

#' @inheritParams SimCor
#' @rdname simdist
#' @export
SimJaccard <- function(pairProfile) {
    .Call('PhyloProfile_SimJaccard', PACKAGE = 'PhyloProfile', pairProfile)
}

#' @inheritParams SimCor
#' @rdname simdist
#' @export
DistHamming <- function(pairProfile) {
    .Call('PhyloProfile_DistHamming', PACKAGE = 'PhyloProfile', pairProfile)
}

#' @inheritParams SimCor
#' @rdname simdist
#' @export
DistEuclidean <- function(pairProfile) {
    .Call('PhyloProfile_DistEuclidean', PACKAGE = 'PhyloProfile', pairProfile)
}

