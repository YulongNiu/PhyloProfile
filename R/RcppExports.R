# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

BatchMat <- function(p, idx, attrs, arguments) {
    .Call(`_PhyloProfileKit_BatchMat`, p, idx, attrs, arguments)
}

BatchBigmat <- function(p, idx, attrs, arguments) {
    .Call(`_PhyloProfileKit_BatchBigmat`, p, idx, attrs, arguments)
}

#' Collapse phylogenetic profiles according to the phylogenetic tree
#'
#' The branches with same profile pattern are merged.
#'
#' @title Collapse tree
#' @return A numeric matrix with four columns: first two are collapsed edges and last two represent collapsed two profiles.
#' @param tipNum A int value. Tip (species) number.
#' @inheritParams SimCor
#' @inheritParams InferEdge
#' @references \href{http://rsif.royalsocietypublishing.org/content/5/19/151}{collapse tree description}
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @keywords internal
CollapseTree <- function(edgeMat, tipNum, f, t) {
    .Call(`_PhyloProfileKit_CollapseTree`, edgeMat, tipNum, f, t)
}

#' Test two rows are equal
#'
#' Pairwise comparison tow rows
#'
#' @title Compare two rows Test
#' @return logic value.
#' @param m A numeric matrix with two rows.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @keywords internal
isTwoRowsEqual <- function(m) {
    .Call(`_PhyloProfileKit_isTwoRowsEqual`, m)
}

#' Use Dollo's parsimony distance to evaluate similarity patterns.
#'
#' Algorithm:
#' 1. Find the latest common ancestors (LCA) for all gain tips.
#' 2. Select the nodes from each tip to the LCA.
#'
#' \code{InferGainNodes()}: Infer the present nodes and tips.
#'
#' \code{DolloDist()}: Infer the Dollo's parsimony distance.
#'
#' \code{InferEdge()}: Infer the present and absent of each edges.
#'
#' @title Dollo's parsimony distance
#' @param gainList A list of ancestors of each gain tips. In each elements, the first one is the root.
#' @return
#'
#' \code{InferGainNodes()}: A vector (with tips) of 1 and 0.
#'
#' \code{DolloDist()}: An integer.
#'
#' \code{InferEdge()}: A numeric edge present and absent matrix.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @rdname dollo
#' @keywords internal
InferGainNodes <- function(gainList) {
    .Call(`_PhyloProfileKit_InferGainNodes`, gainList)
}

#' @param edgeMat A edge mat could be generated from the "ape" package.The first row should be (root --> nodes).
#' @param tipPath  A list of ancestors of each gain tips. In each elements, the first one is the root.
#' @param pr A numeric vector indicates the "presence-absence" pattern."pr" should be in the same order with the tips of tree
#' @rdname dollo
#' @keywords internal
InferEdge <- function(edgeMat, tipPath, pr) {
    .Call(`_PhyloProfileKit_InferEdge`, edgeMat, tipPath, pr)
}

#' @inheritParams SimCor
#' @inheritParams InferEdge
#' @return A number indicating the Dollo's parsimony distance.
#' @rdname dollo
#' @references \url{https://www.ncbi.nlm.nih.gov/pubmed/?term=17535793}
#' @keywords internal
DolloDist <- function(edgeMat, tipPath, f, t) {
    .Call(`_PhyloProfileKit_DolloDist`, edgeMat, tipPath, f, t)
}

#' @param x A list only contains unsigned interger vectors.
#' @return A merged numeric vector.
#' @rdname dollo
#' @keywords internal
MergeList <- function(x) {
    .Call(`_PhyloProfileKit_MergeList`, x)
}

#' Utilities for MI
#'
#' \code{eachMI()}: Info for a cell.
#' \code{Info()}: Entropy.
#' \code{HistTwo()}: Joint counts of two vectors.
#' \code{FindInter()}: Interval indices of a vector.
#' \code{FindInterSingle()}: Interval index of a value.
#' \code{gInter()}: Generate an interval vector, inspired from the \code{cut()} function of the \code{base} package.
#' \code{CountRepeat()}: Repeat counts of a vector.
#'
#' @param p1, p2, p3: Counts of variables in cells.
#' @param n Total variables.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @rdname utilities-MI
#' @keywords internal
eachMI <- function(p1, p2, p3, n) {
    .Call(`_PhyloProfileKit_eachMI`, p1, p2, p3, n)
}

#' @param v Histogram of counts.
#' @inheritParams eachMI
#' @rdname utilities-MI
#' @keywords internal
Info <- function(v, n) {
    .Call(`_PhyloProfileKit_Info`, v, n)
}

#' @param bin A positive \code{integer} indicating the bin.
#' @param x, y \code{numeric vector}.
#' @rdname utilities-MI
#' @keywords internal
HistTwo <- function(x, y, bin) {
    .Call(`_PhyloProfileKit_HistTwo`, x, y, bin)
}

#' @inheritParams HistTwo
#' @param internal Interval numeric vector.
#' @rdname utilities-MI
#' @keywords internal
FindInter <- function(x, interval) {
    .Call(`_PhyloProfileKit_FindInter`, x, interval)
}

#' @inheritParams FindInter
#' @param value Number.
#' @rdname utilities-MI
#' @keywords internal
FindInterSingle <- function(value, interval) {
    .Call(`_PhyloProfileKit_FindInterSingle`, value, interval)
}

#' @inheritParams HistTwo
#' @rdname utilities-MI
#' @keywords internal
gInter <- function(x, bin) {
    .Call(`_PhyloProfileKit_gInter`, x, bin)
}

#' @inheritParams HistTwo
#' @rdname utilities-MI
#' @keywords internal
CountRepeat <- function(x) {
    .Call(`_PhyloProfileKit_CountRepeat`, x)
}

#' NPP normalization
#'
#' Algorithm:
#'
#' Step1: rawBitM < hitCutoff to hitReset;
#'
#' Step2: filter genes without enough homologys
#'
#' Step3: in each row (species), log2(x/max(x));
#'
#' Step4: z-score for each column.
#' 
#' @title z-score normalization of phylogenetic profile
#' @return
#'
#' NPPNorm(): NPP normalized bit score matrix.
#'
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @inheritParams SVDNorm
#' @references \href{http://www.nature.com/nature/journal/v493/n7434/extref/nature11779-s1.pdf}{NPP description}
#' @keywords internal
NPPNorm <- function(rawBitM, bitCutoff, bitReset, minConserve) {
    .Call(`_PhyloProfileKit_NPPNorm`, rawBitM, bitCutoff, bitReset, minConserve)
}

#' SVD normalization
#'
#' Algorithm:
#'
#' Step1: rawBitM < bitCutoff to bitReset;
#'
#' Step2: In each row (species), x/max(x);
#'
#' Step3: L^2 SVD normalization.
#'
#' The core SVD normalization is retrieved from the SVD-Phy package with performance modification.
#' @title Singular value decomposition normalization of bit score matrix
#' @param rawBitM Raw bit score matrix.
#' @param bitCutoff Minimum value of the bit score.
#' @return
#'
#' SVDNorm(): SVD normalized bit score matrix.
#'
#' SVDPhy(): A L^2 normalized unitary matrix.
#'
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @inheritParams SVDPhy
#' @references \href{https://bitbucket.org/andrea/svd-phy}{SVD-Phy package}
#' @references \href{http://bioinformatics.oxfordjournals.org/content/suppl/2015/11/25/btv696.DC1/SVD-Phy-supplementary-material.docx}{SVD description}
#' @rdname normSVD
#' @keywords internal
SVDNorm <- function(rawBitM, bitCutoff, bitReset, minConserve, trimming) {
    .Call(`_PhyloProfileKit_SVDNorm`, rawBitM, bitCutoff, bitReset, minConserve, trimming)
}

#' @param bitM Bit score matrix, for example the BLASTP or STRING bit scores. It is a named numeric matrix, columns are species and rows are genes.
#' @param bitReset Reset the bit score for ones lower than the `bitCutoff`.
#' @param trimming A percentages top unitary matrix.
#' @param minConserve Minimum number of homologous. The proteins with homologous less than this value are discarded.
#' @rdname normSVD
#' @keywords internal
SVDPhy <- function(bitM, bitReset, minConserve, trimming) {
    .Call(`_PhyloProfileKit_SVDPhy`, bitM, bitReset, minConserve, trimming)
}

#' Similarity or distance of paired phylogenetic profile
#'
#' \code{SimCor()}: Person's correlation coefficient.
#'
#' \code{SimJaccard()}: Jaccard similarity.
#'
#' \code{SimMIBin()}: Mutual information for binning data.
#'
#' \code{SimMIConti()}: Mutual information for continuous data.
#'
#' \code{DistHamming()}: Hamming distance.
#'
#' \code{DistEuclidean()}: Euclidean distance.
#'
#' @title Similarity and distance
#' @param f Numeric vector indicating a gene profile.
#' @param t Numeric vector indicating a gene profile.
#' @return A numeric value.
#' @author Yulong Niu \email{yulong.niu@@hotmail.com}
#' @rdname simdist
#' @keywords internal
SimCor <- function(f, t) {
    .Call(`_PhyloProfileKit_SimCor`, f, t)
}

#' @inheritParams SimCor
#' @rdname simdist
#' @keywords internal
SimJaccard <- function(f, t) {
    .Call(`_PhyloProfileKit_SimJaccard`, f, t)
}

#' @inheritParams SimCor
#' @rdname simdist
#' @keywords internal
DistHamming <- function(f, t) {
    .Call(`_PhyloProfileKit_DistHamming`, f, t)
}

#' @inheritParams SimCor
#' @rdname simdist
#' @keywords internal
DistEuclidean <- function(f, t) {
    .Call(`_PhyloProfileKit_DistEuclidean`, f, t)
}

